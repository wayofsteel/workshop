--[[ WoS Enemy Public Resolve and Stunt Counter

A Luddite's Quick Guide to Adding Counter Buttons

Step 1: Add an entry to initial_stat_data.
Step 2: Add the button's function below the others.

When possible, copy-paste from a working button.
Pay close attention; a missing comma can ruin your day.
--]]

--[[ GLOBAL VARIABLES (change in one place, as opposed to all over the place)

hover_time: number of seconds base buttons are visible when a player hovers

stat_defaults: defaults common among all stats
    NOTE: count and min in vals table are named in update_stat_count()

initial_stat_data: all starting stats, button data, and values
    NOTE: click_function in button table is vital to script functionality

    Example for adding a new entry to initial_stat_data:
    {
        button = {--Stat: Coolness Factor, color is #AAAAAA
            click_function = "update_cool_factor",
            hover_color = { r = 170/255, g = 170/255, b = 170/255 },
            position = { x = -2.0, y = 0.1, z = -1.2 }
        },
        vals = {},
    },
--]]
hover_time = 5

function get_stat_defaults(choice)
    local stat_defaults = {
        button = {
            font_size = 160,
            height = 200,
            width = 200,
            color = { r = 0, g = 0, b = 0, a = 0 }
        },
        vals = {
            count = 0,
            min = 0
        }
    } --End of stat_defaults
    return stat_defaults[choice]
end

function get_initial_stat_data()
    return {-- initial_stat_data
        {
            button = {--Resolve: Known Damage
                click_function = "update_known_damage",
                hover_color = { r = 100/255, g = 100/255, b = 100/255 },
                position = { x = 0, y = 0.1, z = -1.5},
                height = 280,
                width = 280,
                font_size = 200
            },
            vals = {
                min = -10
            }
        },
        {
            button = {--Stunt: Offense, color is #B70025
                click_function = "update_stunt_off",
                hover_color = { r = 183/255, g = 0/255, b = 37/255 },
                position = { x = 0.5, y = 0.1, z = -1.5 }
            },
            vals = {}
        },
        {
            button = {--Stunt: Defense, color is #27C75D
                click_function = "update_stunt_def",
                hover_color = { r = 39/255, g = 199/255, b = 93/255 },
                position = { x = 0.875, y = 0.1, z = -1.5 }
            },
            vals = {}
        },
        {
            button = {--Stunt: Mobility, color is #6DA1FD
                click_function = "update_stunt_mob",
                hover_color = { r = 109/255, g = 161/255, b = 253/255 },
                position = { x = 1.25, y = 0.1, z = -1.5 }
            },
            vals = {}
        },
        {
            button = {--Stunt: Tactics, color is #ECC63B
                click_function = "update_stunt_tac",
                hover_color = { r = 236/255, g = 198/255, b = 59/255 },
                position = { x = 1.625, y = 0.1, z = -1.5 }
            },
            vals = {}
        }
    }--End of initial_stat_data
end
--[[ END OF GLOBAL VARIABLES
--]]

--[[ Button Functions

Each button needs its own function. These are all "helper" functions that tell
a common function who is calling, BECAUSE TTS DOESN'T NATIVELY DO THAT.

But a new function could be written to do something completely different.

Example function (don't leave out obj, player, or altclick!):

function say_hello(obj, player, altclick)
    local click_type = altclick and " right-clicked" or " left-clicked"
    print("Player " .. player .. click_type)
end
--]]
function update_known_damage(obj, player, altclick)
    update_stat_count(altclick, "update_known_damage")
end

function update_stunt_off(obj, player, altclick)
    update_stat_count(altclick, "update_stunt_off")
end

function update_stunt_def(obj, player, altclick)
    update_stat_count(altclick, "update_stunt_def")
end

function update_stunt_mob(obj, player, altclick)
    update_stat_count(altclick, "update_stunt_mob")
end

function update_stunt_tac(obj, player, altclick)
    update_stat_count(altclick, "update_stunt_tac")
end
--[[ END OF FUNCTIONS
--]]

--[[ FRIENDLY HEADS-UP: BORING, VITAL PROGRAM GUTS BELOW

    Everything necessary for making a simple button adjustment is above.
    A GM customizing their buttons should almost NEVER have to go below here.
--]]

function onSave()
    return JSON.encode(stats)
end

function onLoad(saved_data)
    stats = build_stats(JSON.decode(saved_data))
end

--[[ onHover() shows buttons for hover_time seconds. (hover_time is a global)
--]]
function onHover(player_color)
    local function make_buttons_invisible(is_visible)
        local color_off = {r = 0, g = 0, b = 0, a = 0}
        local btns = self.getButtons() -- move inside ipairs when bug-free
        for idx, btn in ipairs(btns)
        do
            curr_color = is_visible and color_off or btn.hover_color
            update_button( idx, { color = curr_color } )
        end
    end

    make_buttons_invisible(false)
    Wait.time( function() make_buttons_invisible(true) end, hover_time)
end

--[[ record_button_change() exists in case its role or onSave's has to expand
--]]
function record_button_change()
    self.script_state = onSave()
end

--[[ create_button() is a helper for the createButton method

    I still don't understand why this is necessary. And I don't care.
--]]
function create_button(idx, btn, count)
    self.createButton(btn)
    update_button(idx, {
        function_owner=self,
        click_function=btn.click_function,
        label = tostring(count)
    })
end

--[[ update_button() adjusts for editButton's 0-index in a Lua system. (Wack.)
--]]
function update_button(given_index, changes_table)
    changes_table.index = given_index - 1
    self.editButton(changes_table)
    record_button_change()
end

function override_defaults(attr_name, button_data)
    local curr_tbl = get_stat_defaults(attr_name)

    for key, value in pairs(button_data)
    do
        curr_tbl[key] = value
    end

    return curr_tbl
end

function build_stats(load)
    local arr = {}

    for idx, stat in ipairs(get_initial_stat_data())
    do
        arr[idx] = {}
        for stat_attr, attr_tbl in pairs(stat)
        do
            if load and stat_attr ~= "button"
            then
                arr[idx][stat_attr] = load[idx][stat_attr]
            else
                arr[idx][stat_attr] = override_defaults(stat_attr, attr_tbl)
            end
        end
        create_button(idx, arr[idx].button, arr[idx].vals.count)
    end

    return arr
end

--[[ get_adjusted_count() accounts for a stat minimum
    If a maximum were necessary, the logic would likely fit best here.
]]
function get_adjusted_count(old_count, minimum, adjustment)
    local adjusted_count = old_count + adjustment
    return adjusted_count >= minimum and adjusted_count or minimum
end

function get_stat_index(name)
    for index, stat_button in ipairs(self.getButtons())
    do
        if stat_button.click_function == name then return index end
    end
end

function update_stat_count(is_rclick, name)
    local adjustment = is_rclick and -1 or 1
    local stat_idx = get_stat_index(name)

    stat = stats[stat_idx].vals
    stat.count = get_adjusted_count(stat.count, stat.min, adjustment)
    update_button( stat_idx, { label = tostring(stat.count) } )
end
--End of File
